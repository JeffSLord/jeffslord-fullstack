/* eslint-disable no-plusplus */
/* eslint-disable no-loop-func */
/*
  DOCUMENTATION

  Current features...
  - Identify and fix first level split nodes.
    - If split node has nodes beneath, function will have to be reran multiple times.

  Planned features...
  - Identify unmapped input parameters
  - Identify right joins
    - Untested

*/

const fs = require('fs');
const xml2js = require('xml2js');

const parser = new xml2js.Parser();

function WriteFile(fileName, text) {
  fs.writeFileSync(fileName, text);
}

function ParseFile(filePath, cb) {
  fs.readFile(filePath, 'utf8', (err, data) => {
    parser.parseString(data, (err, result) => {
      WriteFile('cv_json.json', JSON.stringify(result));
      cb(result);
    });
  });
}

function GetCvRoot(jsonResult, cb) {
  const cvRoot = jsonResult['Calculation:scenario'].calculationViews[0].calculationView;
  if (cvRoot === undefined) {
    return cb(Error('No calculation view'));
  }
  return cb(null, cvRoot);
}

function GetLocalVarRoot(jsonResult, cb) {
  const localVarRoot = jsonResult['Calculation:scenario'].localVariables[0].variable;
  if (localVarRoot === undefined) {
    return cb(Error('No local variables'));
  }
  return cb(null, localVarRoot);
}
function GetVarMapRoot(jsonResult, cb) {
  const varMapRoot = jsonResult['Calculation:scenario'].variableMappings[0].mapping;
  if (varMapRoot === undefined) {
    return cb(Error('No variable mappings'));
  }
  return cb(null, varMapRoot);
}
function GetDataSourcesRoot(jsonResult, cb) {
  const dataSourcesRoot = jsonResult['Calculation:scenario'].dataSources[0].DataSource;
  if (dataSourcesRoot === undefined) {
    return cb(Error('No data sources'));
  }
  return cb(null, dataSourcesRoot);
}

function GetDataSource(jsonResult, dsName, cb) {
  GetDataSourcesRoot(jsonResult, (err, root) => {
    if (dsName.charAt(0) === '#') {
      dsName = dsName.substr(1);
    }
  });
}
function GetDataSourceNames(jsonResult, cb) {
  const ds = [];
  GetDataSourcesRoot(jsonResult, (err, root) => {
    root.forEach((ele) => {
      // console.log('ID:', ele.$.id);
      ds.push(ele.$.id);
    });
  });
  // console.log('Data sources:', ds);
  return cb(null, ds);
}
function GetDataSourceByName(jsonResult, cb) {}

// Get CalculationView node by name (id)
function GetCvByName(jsonResult, cvName, cb) {
  // const root = GetCvRoot(jsonResult);
  GetCvRoot(jsonResult, (err, root) => {
    cvName = JSON.parse(cvName);
    if (cvName.charAt(0) === '#') {
      cvName = cvName.substr(1);
    }
    for (let i = 0; i < root.length; i++) {
      if (root[i].$.id === cvName) {
        // console.log(root[i]);
        return cb(root[i]);
      }
    }
  });
}
// Get all CalculationView nodes
function GetCvs(jsonResult) {
  // const root = GetCvRoot(jsonResult);
  GetCvRoot(jsonResult, (err, root) => {
    const res = [];
    for (let i = 0; i < root.length; i++) {
      // console.log(root[i]);
      res.push(root[i]);
    }
    return res;
  });
}

// Get all CalculationView nodes that have specified input node
function GetCvsByInput(jsonResult, inputName, cb) {
  // const root = GetCvRoot(jsonResult);
  GetCvRoot(jsonResult, (err, root) => {
    inputName = JSON.parse(inputName);
    if (inputName.charAt(0) !== '#') {
      inputName = `#${inputName}`;
    }
    const results = [];
    for (let index = 0; index < root.length; index++) {
      for (let j = 0; j < root[index].input.length; j++) {
        const element = root[index].input[j];
        const inp = element.$.node;
        if (inp === inputName) {
          if (results.indexOf(root[index]) === -1) {
            results.push(root[index]);
          }
        }
      }
    }
    return cb(results);
  });
}
// test
function GetInputNodeCounts(jsonResult, cb) {
  const cvs = GetCvs(jsonResult);
  const inputNodes = {};
  cvs.forEach((ele1) => {
    ele1.input.forEach((ele2) => {
      const inputNode = JSON.stringify(ele2.$.node);
      if (inputNode in inputNodes) {
        inputNodes[inputNode] += 1;
      } else {
        inputNodes[inputNode] = 1;
      }
    });
  });
  return cb(inputNodes);
}

// Return array of input nodes
function GetCvInputs(jsonResult, inputName, cb) {
  // inputName = JSON.stringify(inputName);
  // inputName = inputName.slice(1, -1);

  // console.log('input name:', inputName);
  // console.log(inputName);
  // const root = GetCvRoot(jsonResult);
  const nodes = [];
  GetCvsByInput(jsonResult, inputName, (res) => {
    res.forEach((ele) => {
      ele.input.forEach((ele2) => {
        // console.log('TEST:', ele2.$.node);
        // console.log('INPUT:', inputName);
        if (inputName.charAt(0) === '"') {
          inputName = inputName.slice(1, -1);
        }
        if (ele2.$.node === inputName) {
          // console.log('MATCH:', ele2.$.node);
          // console.log(ele2);
          nodes.push(ele2);
        }
      });
    });

    return cb(nodes);
  });
}

// Find all input nodes that are used in more than 1 calc view node
function GetSplitNodes(jsonResult, cb) {
  const splitNodes = {};
  GetInputNodeCounts(jsonResult, (inputNodes) => {
    Object.keys(inputNodes).forEach((key) => {
      if (inputNodes[key] > 1) {
        let parsed = JSON.parse(key);
        parsed = parsed.replace('#', '');
        // if input is a data source, it is not split
        GetDataSourceNames(jsonResult, (err, ds) => {
          if (!ds.includes(parsed)) {
            splitNodes[key] = inputNodes[key];
            // console.log('KEY NOT IN SOURCE');
          }
        });
      }
    });
  });
  return cb(splitNodes);
}

// Duplicate calc view node and return the copy. Does not add to structure.
function CopyCv(jsonResult, cvName, cb) {
  GetCvByName(jsonResult, cvName, (cv) => {
    // duplicate cv into another cv and add it to the root
    const cvCopy = JSON.parse(JSON.stringify(cv));
    return cb(cvCopy);
    // console.log(cvCopy);
  });
}

function GetRightJoinCvs(jsonResult, cb) {
  const cvs = GetCvs(jsonResult);
  const rightOuters = [];
  cvs.forEach((ele) => {
    // console.log(ele.$.joinType);
    if (ele.$.joinType === 'rightOuter') {
      // console.log(ele.$.joinType);
      rightOuters.push(ele);
    }
  });
  return cb(null, rightOuters);
}

// collect all in localVariables section
// param = true?
// check all variable mappings
// if all localVariables are a targetVariable for at least 1 mapping, all input parameters are mapped.
function GetUnmappedParams(jsonResult, cb) {
  // const localVarRoot = GetLocalVarRoot(jsonResult);
  // const varMapRoot = GetVarMapRoot(jsonResult);
  const vars = [];
  const maps = [];
  GetLocalVarRoot(jsonResult, (err, localVarRoot) => {
    if (err) {
      console.log(err);
      return cb(err);
    }
    // console.log('localvarroot:', localVarRoot);
    GetVarMapRoot(jsonResult, (err, varMapRoot) => {
      if (err) {
        console.log(err);
        return cb(err);
      }
      // console.log('varmaproot:', varMapRoot);
      localVarRoot.forEach((ele) => {
        // console.log(ele.$.id);
        vars.push(ele.$.id);
      });
      // console.log(vars);
      // console.log(varMapRoot);
      varMapRoot.forEach((ele) => {
        // console.log(ele);
        const tempName = JSON.stringify(ele.targetVariable[0].$.name);
        // console.log(tempName);
        maps.push(JSON.parse(tempName));
      });
      const unmapped = vars.filter(el => !maps.includes(el));
      console.log('Variables:', vars);
      console.log('Maps', maps);
      return cb(null, unmapped);
    });
  });

  // if (localVarRoot === undefined) {
  //   console.log('UNDEFINED');
  // }

  // console.log('vars', vars);
  // console.log('maps', maps);
  // console.log('unmapped', unmapped);
}

function FixRightJoins(jsonResult, cb) {
  GetRightJoinCvs(jsonResult, (err, rightOuters) => {
    rightOuters.forEach((ele) => {
      ele.$.joinType = 'leftOuter';
      [ele.input[0], ele.input[1]] = [ele.input[1], ele.input[0]];
      // console.log(ele.input.length);
    });
    return cb(null, rightOuters);
  });
}

// need to check if split node is a data source
// if it is a data source than it is allowed to be in multiple places
function FixSplitNodes(jsonResult, cb) {
  // const cvRoot = GetCvRoot(jsonResult);
  GetCvRoot(jsonResult, (err, cvRoot) => {
    let complete = false;
    const allSplits = [];
    while (!complete) {
      // Get input nodes that are used by more than 1 node
      GetSplitNodes(jsonResult, (splitNodes) => {
        // console.log(splitNode);
        if (Object.keys(splitNodes).length === 0) {
          complete = true;
        } else {
          allSplits.push(splitNodes);
          // console.log('Split Nodes:', splitNodes);
          // console.log(Object.keys(splitNodes).length);
          Object.keys(splitNodes).forEach((key) => {
            // Get the calc view nodes based on the name of split inputs
            GetCvInputs(jsonResult, key, (inputNodes) => {
              // console.log('split:', splitNodes);
              // console.log('key:', splitNodes[key]);
              // console.log(inputNodes.length);
              for (let i = 0; i < splitNodes[key] - 1; i++) {
                // console.log(splitNodes[key]);
                // Make a copy for each split (if used in 10 places, create 9 new)
                CopyCv(jsonResult, key, (cvCopy) => {
                  // console.log(cvCopy);
                  // Change the copies id to new id (_i for iteration)
                  cvCopy.$.id = `${cvCopy.$.id}_${i + 1}`;
                  // Add copy to the structure
                  cvRoot.push(cvCopy);
                  // Change input node to the newly created calc view node
                  inputNodes[i].$.node = `#${cvCopy.$.id}`;
                  // console.log(inputNodes[i]);
                });
              }
            });
          });
        }
      });
    }
    return cb(null, allSplits);
  });
}

const filePath = `${__dirname}/cv_mine.xml`;
// const filePath = `${__dirname}/cv_mapped_param.xml`;
ParseFile(filePath, (result) => {
  console.log('\nProcessing...\n');
  FixSplitNodes(result, (err, splitNodes) => {
    // if (err) console.error(err);
    console.log('Split Nodes:', splitNodes);
  });

  FixRightJoins(result, (err, rightOuters) => {
    // if (err) console.error(err);
    console.log('Right Outer Joins:', rightOuters.length);
  });
  GetUnmappedParams(result, (err, unmapped) => {
    // if (err) console.error(err);
    console.log('Unmapped parameters:', unmapped);
  });

  console.log('\nWriting files...');
  WriteFile('cv_json_new.json', JSON.stringify(result));
  const builder = new xml2js.Builder();
  const xml = builder.buildObject(result);
  WriteFile('cv_xml_new.xml', xml);
  // console.log(result);
});

// go through all input nodes
// if it is a split, copy calc view node of split, copy input node in specific calc view node and rename to previous created copy
